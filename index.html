<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <!-- Link to CSS later -->
    <!-- Include Chart.js library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Include Flatpickr library from CDN -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <!-- Include Chart.js Annotation Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>

    <style>

        /* Basic styling for the chart container */
        .chart-container {
            width: 90%;
            max-width: 1000px;
            margin: 20px auto; /* Center the chart */
        }
        .controls {
            text-align: center;
            margin-bottom: 10px; /* Adjusted margin */
        }
        .controls label {
            margin: 0 10px;
        }
        /* Styling for custom date selector */
        #customDateSelector {
             margin-top: 10px;
             padding: 10px;
             border: 1px solid #eee;
             border-radius: 5px;
             display: inline-block; /* Keep it centered */
         }
         #customDateSelector label {
             margin-right: 5px;
         }
         #flatpickrInput {
             padding: 5px 8px;
             border: 1px solid #ccc;
             border-radius: 4px;
         }
         /* Styling for loading indicator */
         #loadingIndicator {
             margin: 15px;
             font-weight: bold;
             color: #555;
         }
         /* Basic tooltip styling */
         .chartjs-tooltip {
             background: rgba(0, 0, 0, 0.7); */
             color: white;
         }
    </style>
</head>

<body>
    <h1>Terrarium Monitor Dashboard</h1>

    <!-- Controls for Time Range and Auto-Refresh -->
    <div class="controls">
        <label for="timeRangeSelect">Time Range:</label>
        <select id="timeRangeSelect">
            <option value="hour" selected>Last Hour</option>
            <option value="8hour">Last 8 Hours</option>
            <option value="day">Today</option>
            <option value="week">This Week</option>
            <option value="month">This Month</option>
            <option value="custom">Custom Range...</option>
        </select>

        <label for="autoRefreshCheckbox">
            <input type="checkbox" id="autoRefreshCheckbox" checked> Auto-Refresh (1 min)
        </label>
    </div>

    <!-- Hidden container for the custom date selector -->
    <div id="customDateSelector" style="display: none; text-align: center;">
        <label for="flatpickrInput">Select Range:</label>
        <input type="text" id="flatpickrInput" placeholder="Click to select date range...">
    </div>

     <!-- Loading Indicator -->
     <div id="loadingIndicator" style="display: none; text-align: center;">
         Loading chart data...
     </div>

    <!-- Canvas element for the chart -->
    <div class="chart-container">
        <canvas id="sensorChart"></canvas>
    </div>

    <!-- Keeping the latest readings display for testing purposes -->
    <h2>Latest Readings (API Test)</h2>
    <pre id="latest-data">Loading...</pre>

    <script>
        // Fetch raw latest data (keep for testing)
        fetch('/api/readings/latest')
            .then(response => response.json())
            .then(data => {
                document.getElementById('latest-data').textContent = JSON.stringify(data, null, 2);
            })
            .catch(error => {
                console.error('Error fetching latest readings:', error);
                document.getElementById('latest-data').textContent = 'Error loading latest data.';
            });

        // --- Charting Code ---
        const ctx = document.getElementById('sensorChart').getContext('2d');
        const timeRangeSelect = document.getElementById('timeRangeSelect');
        const autoRefreshCheckbox = document.getElementById('autoRefreshCheckbox');
        const customDateSelector = document.getElementById('customDateSelector');
        const flatpickrInput = document.getElementById('flatpickrInput');
        const loadingIndicator = document.getElementById('loadingIndicator');

        let sensorChart;
        let currentRange = timeRangeSelect.value;
        let refreshIntervalId = null;
        const REFRESH_INTERVAL_MS = 60000;

        let selectedStartDate = null;
        let selectedEndDate = null;
        let currentGaps = []; // Store gap info

        // --- Initialize Flatpickr ---
        const fp = flatpickr(flatpickrInput, {
            mode: "range",
            dateFormat: "Y-m-d",
            maxDate: "today",
            onChange: function(selectedDates, dateStr, instance) {
                if (selectedDates.length === 2) {
                    selectedStartDate = selectedDates[0];
                    selectedEndDate = selectedDates[1];
                    const startDateStr = selectedStartDate.toISOString().split('T')[0];
                    const endDateStr = selectedEndDate.toISOString().split('T')[0];
                    console.log(`Custom range selected via calendar: ${startDateStr} to ${endDateStr}`);
                    updateChart(null, startDateStr, endDateStr);
                } else {
                    selectedStartDate = null;
                    selectedEndDate = null;
                }
            }
        });

        // --- Chart Update Function ---
        function updateChart(range, startDate, endDate) {
             let fetchUrl;
             let isCustomRange = false;

             if (startDate && endDate) {
                 fetchUrl = `/api/chartdata?start_date=${startDate}&end_date=${endDate}`;
                 console.log(`Fetching custom range: ${startDate} to ${endDate}`);
                 isCustomRange = true;
                 if (autoRefreshCheckbox.checked) {
                     autoRefreshCheckbox.checked = false;
                     stopAutoRefresh();
                 }
                 autoRefreshCheckbox.disabled = true;
             } else if (range && range !== "custom") {
                 fetchUrl = `/api/chartdata?range=${range}`;
                 console.log(`Fetching relative range: ${range}`);
                 autoRefreshCheckbox.disabled = false;
                 currentGaps = []; // Clear gaps for relative ranges
             } else if (range === "custom") {
                  console.log("Custom range selected, waiting for date input...");
                  return;
             } else {
                 console.error("updateChart called without valid range or dates!");
                 return;
             }

            loadingIndicator.style.display = 'block';

            fetch(fetchUrl)
                .then(response => {
                    if (!response.ok) {
                         // Try to parse error JSON from backend
                         return response.json().then(errData => {
                             throw new Error(`HTTP error! status: ${response.status}, message: ${errData.error || 'Unknown error'}`);
                         }).catch(() => {
                             // Fallback if error response is not JSON
                             throw new Error(`HTTP error! status: ${response.status}`);
                         });
                    }
                    return response.json();
                })
                .then(data => {
                    // Validation of received data structure
                    if (!data || !data.labels || !data.temperatures || !data.humidities) {
                        console.error("Received invalid data format for chart:", data);
                        currentGaps = []; // Clear gaps on error
                        // Display error to user on the chart
                        if (sensorChart) {
                             sensorChart.options.plugins.title.text = 'Error: Invalid data received';
                             sensorChart.data.labels = [];
                             sensorChart.data.datasets[0].data = [];
                             sensorChart.data.datasets[1].data = [];
                             sensorChart.update();
                        }
                        return;
                    }

                    // Store gap info for tooltips
                    currentGaps = data.gaps || [];

                    // Determine Chart Title
                    let chartTitleText = '';
                    if (isCustomRange) {
                        chartTitleText = startDate === endDate
                            ? `Terrarium Readings (${startDate})`
                            : `Terrarium Readings (${startDate} to ${endDate})`;
                    } else {
                        chartTitleText = `Terrarium Readings (${timeRangeSelect.options[timeRangeSelect.selectedIndex].text})`;
                    }

                    // --- Generate Annotations from Gaps ---
                    const annotations = currentGaps.map(gap => ({
                        type: 'box',
                        // Use the labels provided by the backend which flank the gap
                        xMin: gap.start,
                        xMax: gap.end,
                        backgroundColor: 'rgba(200, 200, 200, 0.3)', // Light grey transparent background
                        borderColor: 'rgba(180, 180, 180, 0.4)',
                        borderWidth: 1,
                        label: { // Add a label to the annotation box itself
                             display: false, // Keep it clean for now, can enable later
                             content: 'No Data',
                             position: 'center'
                         }
                    }));

                    // Define chart configuration
                    const chartConfig = {
                        type: 'line',
                        data: {
                            labels: data.labels,
                            datasets: [
                                {
                                    label: 'Temperature (°C)',
                                    data: data.temperatures,
                                    borderColor: 'rgb(255, 99, 132)',
                                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                    yAxisID: 'yTemp',
                                    tension: 0.1
                                },
                                {
                                    label: 'Humidity (%)',
                                    data: data.humidities,
                                    borderColor: 'rgb(54, 162, 235)',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    yAxisID: 'yHumid',
                                    tension: 0.1
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            animation: {
                                duration: 200
                            },
                            scales: {
                                x: {
                                    title: { display: true, text: 'Time' },
                                    ticks: {
                                        autoSkip: true,
                                        maxTicksLimit: 20
                                    }
                                },
                                yTemp: {
                                    type: 'linear',
                                    position: 'left',
                                    title: { display: true, text: 'Temperature (°C)' },
                                    suggestedMin: 10,
                                    suggestedMax: 35
                                },
                                yHumid: {
                                    type: 'linear',
                                    position: 'right',
                                    title: { display: true, text: 'Humidity (%)' },
                                    suggestedMin: 0,
                                    suggestedMax: 100,
                                    grid: { drawOnChartArea: false }
                                }
                            },
                            plugins: {
                                 legend: { position: 'top' },
                                 title: { display: true, text: chartTitleText },
                                 // --- Annotation Plugin Configuration ---
                                 annotation: {
                                     annotations: annotations // Assign generated annotations
                                 },
                                 // --- Tooltip Configuration ---
                                 tooltip: {
                                     callbacks: {
                                         // Add extra info after the default label (like Temp/Humidity)
                                         afterLabel: function(context) {
                                             // context.label is the X-axis label (e.g., "2023-10-27 15:30")
                                             // context.dataIndex is the index in the data array
                                             const currentLabel = context.label;
                                             let gapMessage = null;

                                             // Check if the previous point was the start of a gap ending at the current point
                                             if (context.dataIndex > 0) {
                                                 const prevLabel = context.chart.data.labels[context.dataIndex - 1];
                                                 for (const gap of currentGaps) {
                                                     // Check if the previous label matches gap start and current label matches gap end
                                                     if (gap.start === prevLabel && gap.end === currentLabel) {
                                                         gapMessage = 'No readings during prior gap';
                                                         break; // Found the relevant gap
                                                     }
                                                 }
                                             }
                                             return gapMessage; // Return the message or null
                                         }
                                     }
                                 }
                             }
                        }
                    };

                    // Update or create chart
                    if (sensorChart) {
                        // Update data and annotation options
                        sensorChart.data.labels = data.labels;
                        sensorChart.data.datasets[0].data = data.temperatures;
                        sensorChart.data.datasets[1].data = data.humidities;
                        sensorChart.options.plugins.title.text = chartTitleText;
                        sensorChart.options.plugins.annotation.annotations = annotations;
                        sensorChart.update();
                        console.log(`Chart updated. Range: ${isCustomRange ? (startDate + ' to ' + endDate) : range}. Points: ${data.labels.length}. Gaps: ${currentGaps.length}`);
                    } else {
                        // Ensure Chart.register(Annotation) is called if auto-registration doesn't work
                         if (window.ChartAnnotation) { // Check if plugin is loaded
                             console.log("Annotation plugin registered.");
                         } else {
                            console.warn("Annotation plugin might not be registered!");
                         }
                        sensorChart = new Chart(ctx, chartConfig);
                        console.log(`Chart created. Range: ${isCustomRange ? (startDate + ' to ' + endDate) : range}. Points: ${data.labels.length}. Gaps: ${currentGaps.length}`);
                    }
                })
                .catch(error => {
                    console.error('Error fetching or processing chart data:', error);
                    currentGaps = []; // Clear gaps on error
                    // Display error message to user
                    if (sensorChart) {
                         sensorChart.options.plugins.title.text = `Error: ${error.message || 'Failed to load data'}`;
                         sensorChart.data.labels = [];
                         sensorChart.data.datasets[0].data = [];
                         sensorChart.data.datasets[1].data = [];
                         // Clear annotations on error
                         sensorChart.options.plugins.annotation.annotations = [];
                         sensorChart.update();
                    } else {
                        // If chart doesn't exist yet, maybe update a status div
                        loadingIndicator.textContent = `Error: ${error.message || 'Failed to load data'}`;
                        loadingIndicator.style.display = 'block'; // Ensure it's visible
                    }
                })
                .finally(() => {
                     // Hide loading indicator unless it's displaying an error from the catch block above
                     if (!loadingIndicator.textContent.startsWith("Error:")) {
                        loadingIndicator.style.display = 'none';
                     }
                });
        }

        // --- Event Listener for Time Range Dropdown Change ---
        timeRangeSelect.addEventListener('change', (event) => {
            currentRange = event.target.value;
            stopAutoRefresh();

            if (currentRange === "custom") {
                customDateSelector.style.display = 'block';
                autoRefreshCheckbox.checked = false;
                autoRefreshCheckbox.disabled = true;
                 if (sensorChart) {
                     sensorChart.options.plugins.title.text = 'Select Custom Date Range';
                     sensorChart.update('none');
                 }
                 fp.open();
            } else {
                customDateSelector.style.display = 'none';
                autoRefreshCheckbox.disabled = false;
                selectedStartDate = null;
                selectedEndDate = null;
                fp.clear();
                updateChart(currentRange, null, null); // Will clear gaps array
                startAutoRefresh();
            }
        });

        // --- Auto-Refresh Logic ---
        function startAutoRefresh() {
            if (autoRefreshCheckbox.checked && !autoRefreshCheckbox.disabled && refreshIntervalId === null) {
                console.log("Starting auto-refresh...");
                refreshIntervalId = setInterval(() => {
                     if (currentRange !== "custom") {
                         updateChart(currentRange, null, null);
                     } else {
                         stopAutoRefresh();
                     }
                }, REFRESH_INTERVAL_MS);
            } else if (!autoRefreshCheckbox.checked || autoRefreshCheckbox.disabled) {
                 console.log("Auto-refresh not starting (disabled or unchecked).");
            } else {
                 console.log("Auto-refresh already running.");
            }
        }

        function stopAutoRefresh() {
            if (refreshIntervalId !== null) {
                console.log("Stopping auto-refresh...");
                clearInterval(refreshIntervalId);
                refreshIntervalId = null;
            }
        }

        // Event Listener for Auto-Refresh Checkbox Change
        autoRefreshCheckbox.addEventListener('change', () => {
            if (autoRefreshCheckbox.checked) {
                if (!autoRefreshCheckbox.disabled) {
                    startAutoRefresh();
                }
            } else {
                stopAutoRefresh();
            }
        });

        // --- Initial Load ---
        updateChart(currentRange, null, null);
        startAutoRefresh();

    </script>
</body>
</html>
